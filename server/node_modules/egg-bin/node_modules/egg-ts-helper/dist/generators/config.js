"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const config_1 = require("../config");
const utils = tslib_1.__importStar(require("../utils"));
const EXPORT_DEFAULT_FUNCTION = 1;
const EXPORT_DEFAULT = 2;
const EXPORT = 3;
const cache = {};
exports.defaultConfig = {
    // only need to parse config.default.ts or config.ts
    pattern: 'config(.default|).(ts|js)',
    interface: config_1.declMapping.config,
};
function default_1(config, baseConfig) {
    const fileList = config.fileList;
    const dist = path_1.default.resolve(config.dtsDir, 'index.d.ts');
    if (!fileList.length) {
        return { dist };
    }
    const importList = [];
    const declarationList = [];
    const moduleList = [];
    fileList.forEach(f => {
        const abUrl = path_1.default.resolve(config.dir, f);
        // read from cache
        if (!cache[abUrl] || config.file === abUrl) {
            const type = checkConfigReturnType(abUrl);
            const { moduleName: sModuleName } = utils.getModuleObjByPath(f);
            const moduleName = `Export${sModuleName}`;
            const importContext = utils.getImportStr(config.dtsDir, abUrl, moduleName, type === EXPORT);
            let tds = `type ${sModuleName} = `;
            if (type === EXPORT_DEFAULT_FUNCTION) {
                tds += `ReturnType<typeof ${moduleName}>;`;
            }
            else if (type === EXPORT_DEFAULT || type === EXPORT) {
                tds += `typeof ${moduleName};`;
            }
            else {
                return;
            }
            // cache the file
            cache[abUrl] = {
                import: importContext,
                declaration: tds,
                moduleName: sModuleName,
            };
        }
        const cacheItem = cache[abUrl];
        importList.push(cacheItem.import);
        declarationList.push(cacheItem.declaration);
        moduleList.push(cacheItem.moduleName);
    });
    if (!importList.length) {
        return { dist };
    }
    const newConfigType = `New${config.interface}`;
    return {
        dist,
        content: `import { ${config.interface} } from '${baseConfig.framework}';\n` +
            `${importList.join('\n')}\n` +
            `${declarationList.join('\n')}\n` +
            `type ${newConfigType} = ${moduleList.join(' & ')};\n` +
            `declare module '${baseConfig.framework}' {\n` +
            `  interface ${config.interface} extends ${newConfigType} { }\n` +
            '}',
    };
}
exports.default = default_1;
// check config return type.
function checkConfigReturnType(f) {
    const result = utils.findExportNode(fs_1.default.readFileSync(f, 'utf-8'));
    if (result.exportDefaultNode) {
        return typescript_1.default.isFunctionLike(result.exportDefaultNode)
            ? EXPORT_DEFAULT_FUNCTION
            : EXPORT_DEFAULT;
    }
    else if (result.exportNodeList.length) {
        return EXPORT;
    }
}
exports.checkConfigReturnType = checkConfigReturnType;
//# sourceMappingURL=config.js.map